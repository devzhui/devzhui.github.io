<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小灰灰</title>
    <description>编码生涯的点点滴滴</description>
    <link>http://0.0.0.0:4000/</link>
    <atom:link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 08 Feb 2017 20:25:22 +0800</pubDate>
    <lastBuildDate>Wed, 08 Feb 2017 20:25:22 +0800</lastBuildDate>
    <generator>Jekyll v3.3.0</generator>
    
      <item>
        <title>log4j.proprities 配置详情</title>
        <description>&lt;h1 id=&quot;log4j&quot;&gt;log4j配置详解&lt;/h1&gt;
&lt;p&gt;Log4J的配置文件(Configuration File)就是用来设置记录器的级别、存放器和布局的，它可接key=value格式的设置或xml格式的设置信息。通过配置，可以创建出Log4J的运行环境。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1. 配置文件&lt;/h2&gt;
&lt;p&gt;Log4J配置文件的基本格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;#配置根Logger
log4j.rootLogger = [ level ],appenderName1,appenderName2, …

#配置日志信息输出目的地Appender
log4j.appender.appenderName  =  fully.qualified.name.of.appender.class 
log4j.appender.appenderName.option1  =  value1 
… 
log4j.appender.appenderName.optionN  =  valueN 

#配置日志信息的格式（布局）
log4j.appender.appenderName.layout  =  fully.qualified.name.of.layout.class 
log4j.appender.appenderName.layout.option1  =  value1 
… 
log4j.appender.appenderName.layout.optionN  =  valueN 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 [level] 是日志输出级别，共有5级：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FATAL      0  
ERROR      3  
WARN       4  
INFO       6  
DEBUG      7 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Appender 为日志输出目的地，Log4j提供的appender有以下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;org.apache.log4j.ConsoleAppender（控制台），
org.apache.log4j.FileAppender（文件），
org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），
org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），
org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Layout：日志输出格式，Log4j提供的layout有以下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;org.apache.log4j.HTMLLayout（以HTML表格形式布局），
org.apache.log4j.PatternLayout（可以灵活地指定布局模式），
org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），
org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印参数: Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 　 %m   输出代码中指定的消息
　　%p   输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL 
　　%r   输出自应用启动到输出该log信息耗费的毫秒数 
　　%c   输出所属的类目，通常就是所在类的全名 
　　%t   输出产生该日志事件的线程名 
　　%n   输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n” 
　　%d   输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日  22 ： 10 ： 28， 921  
　　%l   输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 ) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;logger&quot;&gt;2. 在代码中初始化Logger: &lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;在程序中调用BasicConfigurator.configure()方法：给根记录器增加一个ConsoleAppender，输出格式通过PatternLayout设为”%-4r [%t] %-5p %c %x - %m%n”，还有根记录器的默认级别是Level.DEBUG. &lt;/li&gt;
  &lt;li&gt;配置放在文件里，通过命令行参数传递文件名字，通过PropertyConfigurator.configure(args[x])解析并配置；&lt;/li&gt;
  &lt;li&gt;配置放在文件里，通过环境变量传递文件名等信息，利用log4j默认的初始化过程解析并配置;&lt;/li&gt;
  &lt;li&gt;配置放在文件里，通过应用服务器配置传递文件名等信息，利用一个特殊的servlet来完成配置。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;appender-&quot;&gt;3. 为不同的 Appender 设置日志输出级别：&lt;/h2&gt;
&lt;p&gt;当调试系统时，我们往往注意的只是异常级别的日志输出，但是通常所有级别的输出都是放在一个文件里的，如果日志输出的级别是BUG！？那就慢慢去找吧。
   这时我们也许会想要是能把异常信息单独输出到一个文件里该多好啊。当然可以，Log4j已经提供了这样的功能，我们只需要在配置中修改Appender的Threshold 就能实现,比如下面的例子：&lt;/p&gt;

&lt;p&gt;[配置文件]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;### set log levels ###
log4j.rootLogger = debug ,  stdout ,  D ,  E

### 输出到控制台 ###
log4j.appender.stdout = org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target = System.out
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern =  %d{ABSOLUTE} %5p %c{ 1 }:%L - %m%n

### 输出到日志文件 ###
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
log4j.appender.D.File = logs/log.log
log4j.appender.D.Append = true
log4j.appender.D.Threshold = DEBUG ## 输出DEBUG级别以上的日志
log4j.appender.D.layout = org.apache.log4j.PatternLayout
log4j.appender.D.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n

### 保存异常信息到单独文件 ###
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
log4j.appender.D.File = logs/error.log ## 异常日志文件名
log4j.appender.D.Append = true
log4j.appender.D.Threshold = ERROR ## 只输出ERROR级别以上的日志!!!
log4j.appender.D.layout = org.apache.log4j.PatternLayout
log4j.appender.D.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[代码中使用] &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public   class  TestLog4j  {
     public   static   void  main(String[] args)  {
        PropertyConfigurator.configure( &quot; D:/Code/conf/log4j.properties &quot; );
        Logger logger  =  Logger.getLogger(TestLog4j. class );
        logger.debug( &quot; debug &quot; );
        logger.error( &quot; error &quot; );
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行一下，看看异常信息是不是保存在了一个单独的文件error.log中&lt;/p&gt;

&lt;h2 id=&quot;log4jproperties-&quot;&gt;log4j.properties 使用&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;一.参数意义说明&lt;/h3&gt;
&lt;p&gt;输出级别的种类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR、WARN、INFO、DEBUG
ERROR 为严重错误 主要是程序的错误
WARN 为一般警告，比如session丢失
INFO 为一般要显示的信息，比如登录登出
DEBUG 为程序的调试信息
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置日志信息输出目的地&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log4j.appender.appenderName = fully.qualified.name.of.appender.class
1.org.apache.log4j.ConsoleAppender（控制台）
2.org.apache.log4j.FileAppender（文件）
3.org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）
4.org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）
5.org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置日志信息的格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class
1.org.apache.log4j.HTMLLayout（以HTML表格形式布局），
2.org.apache.log4j.PatternLayout（可以灵活地指定布局模式），
3.org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），
4.org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;控制台选项&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Threshold=DEBUG:指定日志消息的输出最低层次。
ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。
Target=System.err：默认情况下是：System.out,指定输出控制台
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;FileAppender 选项&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Threshold=DEBUF:指定日志消息的输出最低层次。
ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。
File=mylog.txt:指定消息输出到mylog.txt文件。
Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RollingFileAppender 选项&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Threshold=DEBUG:指定日志消息的输出最低层次。
ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。
File=mylog.txt:指定消息输出到mylog.txt文件。
Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。
MaxFileSize=100KB: 后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件。
MaxBackupIndex=2:指定可以产生的滚动文件的最大数。
log4j.appender.A1.layout.ConversionPattern=%-4r %-5p %d{yyyy-MM-dd HH:mm:ssS} %c %m%n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日志信息格式中几个符号所代表的含义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; -X号: X信息输出时左对齐；
 %p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL,
 %d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921
 %r: 输出自应用启动到输出该log信息耗费的毫秒数
 %c: 输出日志信息所属的类目，通常就是所在类的全名
 %t: 输出产生该日志事件的线程名
 %l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main (TestLog4.java:10)
 %x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。
 %%: 输出一个&quot;%&quot;字符
 %F: 输出日志消息产生时所在的文件名称
 %L: 输出代码中的行号
 %m: 输出代码中指定的消息,产生的日志具体信息
 %n: 输出一个回车换行符，Windows平台为&quot;\r\n&quot;，Unix平台为&quot;\n&quot;输出日志信息换行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。&lt;/li&gt;
  &lt;li&gt;%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，”-“号指定左对齐。&lt;/li&gt;
  &lt;li&gt;%.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。&lt;/li&gt;
  &lt;li&gt;%20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边较远输出的字符截掉。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;二.文件配置&lt;/h3&gt;

&lt;h4 id=&quot;sample1&quot;&gt;Sample1&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;log4j.rootLogger=DEBUG,A1,R
#log4j.rootLogger=INFO,A1,R
# ConsoleAppender 输出
log4j.appender.A1=org.apache.log4j.ConsoleAppender
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%c]-[%p] %m%n
# File 输出 一天一个文件,输出路径可以定制,一般在根路径下
log4j.appender.R=org.apache.log4j.DailyRollingFileAppender
log4j.appender.R.File=blog_log.txt
log4j.appender.R.MaxFileSize=500KB
log4j.appender.R.MaxBackupIndex=10
log4j.appender.R.layout=org.apache.log4j.PatternLayout
log4j.appender.R.layout.ConversionPattern=[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;sample2&quot;&gt;文件配置Sample2&lt;/h4&gt;
&lt;p&gt;下面给出的Log4J配置文件实现了输出到控制台，文件，回滚文件，发送日志邮件，输出到数据库日志表，自定义标签等全套功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;log4j.rootLogger=DEBUG,CONSOLE,A1,im 
#DEBUG,CONSOLE,FILE,ROLLING_FILE,MAIL,DATABASE
log4j.addivity.org.apache=true
################### 
# Console Appender 
################### 
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender 
log4j.appender.Threshold=DEBUG 
log4j.appender.CONSOLE.Target=System.out 
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout 
log4j.appender.CONSOLE.layout.ConversionPattern=[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n

#log4j.appender.CONSOLE.layout.ConversionPattern=[start]%d{DATE}[DATE]%n%p[PRIORITY]%n%x[NDC]%n%t[THREAD] n%c[CATEGORY]%n%m[MESSAGE]%n%n
##################### 
# File Appender 
##################### 
log4j.appender.FILE=org.apache.log4j.FileAppender 
log4j.appender.FILE.File=file.log 
log4j.appender.FILE.Append=false 
log4j.appender.FILE.layout=org.apache.log4j.PatternLayout 
log4j.appender.FILE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n 
# Use this layout for LogFactor 5 analysis
######################## 
# Rolling File 
######################## 
log4j.appender.ROLLING_FILE=org.apache.log4j.RollingFileAppender 
log4j.appender.ROLLING_FILE.Threshold=ERROR 
log4j.appender.ROLLING_FILE.File=rolling.log 
log4j.appender.ROLLING_FILE.Append=true 
log4j.appender.ROLLING_FILE.MaxFileSize=10KB 
log4j.appender.ROLLING_FILE.MaxBackupIndex=1 
log4j.appender.ROLLING_FILE.layout=org.apache.log4j.PatternLayout 
log4j.appender.ROLLING_FILE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n
#################### 
# Socket Appender 
#################### 
log4j.appender.SOCKET=org.apache.log4j.RollingFileAppender 
log4j.appender.SOCKET.RemoteHost=localhost 
log4j.appender.SOCKET.Port=5001 
log4j.appender.SOCKET.LocationInfo=true 
# Set up for Log Facter 5 
log4j.appender.SOCKET.layout=org.apache.log4j.PatternLayout 
log4j.appender.SOCET.layout.ConversionPattern=[start]%d{DATE}[DATE]%n%p[PRIORITY]%n%x[NDC]%n%t[THREAD]%n%c[CATEGORY]%n%m[MESSAGE]%n%n
######################## 
# Log Factor 5 Appender 
######################## 
log4j.appender.LF5_APPENDER=org.apache.log4j.lf5.LF5Appender 
log4j.appender.LF5_APPENDER.MaxNumberOfRecords=2000
######################## 
# SMTP Appender 
####################### 
log4j.appender.MAIL=org.apache.log4j.net.SMTPAppender 
log4j.appender.MAIL.Threshold=FATAL 
log4j.appender.MAIL.BufferSize=10 
log4j.appender.MAIL.From=chenyl@yeqiangwei.com
log4j.appender.MAIL.SMTPHost=mail.hollycrm.com 
log4j.appender.MAIL.Subject=Log4J Message 
log4j.appender.MAIL.To=chenyl@yeqiangwei.com
log4j.appender.MAIL.layout=org.apache.log4j.PatternLayout 
log4j.appender.MAIL.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n
######################## 
# JDBC Appender 
####################### 
log4j.appender.DATABASE=org.apache.log4j.jdbc.JDBCAppender 
log4j.appender.DATABASE.URL=jdbc:mysql://localhost:3306/test 
log4j.appender.DATABASE.driver=com.mysql.jdbc.Driver 
log4j.appender.DATABASE.user=root 
log4j.appender.DATABASE.password= 
log4j.appender.DATABASE.sql=INSERT INTO LOG4J (Message) VALUES ('[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n') 
log4j.appender.DATABASE.layout=org.apache.log4j.PatternLayout 
log4j.appender.DATABASE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n
log4j.appender.A1=org.apache.log4j.DailyRollingFileAppender 
log4j.appender.A1.File=SampleMessages.log4j 
log4j.appender.A1.DatePattern=yyyyMMdd-HH'.log4j' 
log4j.appender.A1.layout=org.apache.log4j.xml.XMLLayout
################### 
#自定义Appender 
################### 
log4j.appender.im = net.cybercorlin.util.logger.appender.IMAppender
log4j.appender.im.host = mail.cybercorlin.net 
log4j.appender.im.username = username 
log4j.appender.im.password = password 
log4j.appender.im.recipient = corlin@yeqiangwei.com
log4j.appender.im.layout=org.apache.log4j.PatternLayout 
log4j.appender.im.layout.ConversionPattern =[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;三.高级使用&lt;/h3&gt;
&lt;p&gt;实验目的：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;把FATAL级错误写入2000NT日志&lt;/li&gt;
  &lt;li&gt;WARN，ERROR，FATAL级错误发送email通知管理员&lt;/li&gt;
  &lt;li&gt;其他级别的错误直接在后台输出&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实验步骤：输出到2000NT日志&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;把Log4j压缩包里的NTEventLogAppender.dll拷到WINNT\SYSTEM32目录下&lt;/li&gt;
  &lt;li&gt;写配置文件log4j.properties
    &lt;pre&gt;&lt;code&gt;# 在2000系统日志输出
 log4j.logger.NTlog=FATAL, A8
 # APPENDER A8
 log4j.appender.A8=org.apache.log4j.nt.NTEventLogAppender
 log4j.appender.A8.Source=JavaTest
 log4j.appender.A8.layout=org.apache.log4j.PatternLayout
 log4j.appender.A8.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;调用代码：
    &lt;pre&gt;&lt;code&gt; Logger logger2 = Logger.getLogger(&quot;NTlog&quot;); //要和配置文件中设置的名字相同
 logger2.debug(&quot;debug!!!&quot;);
 logger2.info(&quot;info!!!&quot;);
 logger2.warn(&quot;warn!!!&quot;);
 logger2.error(&quot;error!!!&quot;);
 //只有这个错误才会写入2000日志
 logger2.fatal(&quot;fatal!!!&quot;);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;发送email通知管理员：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先下载JavaMail和JAF, 
    &lt;pre&gt;&lt;code&gt;   http://java.sun.com/j2ee/ja/javamail/index.html
   http://java.sun.com/beans/glasgow/jaf.html
  在项目中引用mail.jar和activation.jar。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;写配置文件
    &lt;pre&gt;&lt;code&gt; # 将日志发送到email
 log4j.logger.MailLog=WARN,A5
 #  APPENDER A5
 log4j.appender.A5=org.apache.log4j.net.SMTPAppender
 log4j.appender.A5.BufferSize=5
 log4j.appender.A5.To=chunjie@yeqiangwei.com
 log4j.appender.A5.From=error@yeqiangwei.com
 log4j.appender.A5.Subject=ErrorLog
 log4j.appender.A5.SMTPHost=smtp.263.net
 log4j.appender.A5.layout=org.apache.log4j.PatternLayout
 log4j.appender.A5.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;调用代码：
    &lt;pre&gt;&lt;code&gt; //把日志发送到mail
 Logger logger3 = Logger.getLogger(&quot;MailLog&quot;);
 logger3.warn(&quot;warn!!!&quot;);
 logger3.error(&quot;error!!!&quot;);
 logger3.fatal(&quot;fatal!!!&quot;);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在后台输出所有类别的错误：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt; 1. 写配置文件
 # 在后台输出
 log4j.logger.console=DEBUG, A1
 # APPENDER A1
 log4j.appender.A1=org.apache.log4j.ConsoleAppender
 log4j.appender.A1.layout=org.apache.log4j.PatternLayout
 log4j.appender.A1.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n
 2．调用代码
 Logger logger1 = Logger.getLogger(&quot;console&quot;);
 logger1.debug(&quot;debug!!!&quot;);
 logger1.info(&quot;info!!!&quot;);
 logger1.warn(&quot;warn!!!&quot;);
 logger1.error(&quot;error!!!&quot;);
 logger1.fatal(&quot;fatal!!!&quot;);
--------------------------------------------------------------------
 全部配置文件：log4j.properties
 # 在后台输出
 log4j.logger.console=DEBUG, A1
 # APPENDER A1
 log4j.appender.A1=org.apache.log4j.ConsoleAppender
 log4j.appender.A1.layout=org.apache.log4j.PatternLayout
 log4j.appender.A1.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n
# 在2000系统日志输出
 log4j.logger.NTlog=FATAL, A8
 # APPENDER A8
 log4j.appender.A8=org.apache.log4j.nt.NTEventLogAppender
 log4j.appender.A8.Source=JavaTest
 log4j.appender.A8.layout=org.apache.log4j.PatternLayout
 log4j.appender.A8.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n
# 将日志发送到email
 log4j.logger.MailLog=WARN,A5
 #  APPENDER A5
 log4j.appender.A5=org.apache.log4j.net.SMTPAppender
 log4j.appender.A5.BufferSize=5
 log4j.appender.A5.To=chunjie@yeqiangwei.com
 log4j.appender.A5.From=error@yeqiangwei.com
 log4j.appender.A5.Subject=ErrorLog
 log4j.appender.A5.SMTPHost=smtp.263.net
 log4j.appender.A5.layout=org.apache.log4j.PatternLayout
 log4j.appender.A5.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全部代码：Log4jTest.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/* 
* 创建日期 2003-11-13 
      */ 
     package edu.bcu.Bean; 
     import org.apache.log4j.*; 
     //import org.apache.log4j.nt.*; 
     //import org.apache.log4j.net.*; 
     /** 
* @author yanxu 
      */ 
     public class Log4jTest 
     { 
      public static void main(String args[]) 
      { 
       PropertyConfigurator.configure(&quot;log4j.properties&quot;); 
       //在后台输出 
       Logger logger1 = Logger.getLogger(&quot;console&quot;); 
       logger1.debug(&quot;debug!!!&quot;); 
       logger1.info(&quot;info!!!&quot;); 
       logger1.warn(&quot;warn!!!&quot;); 
       logger1.error(&quot;error!!!&quot;); 
       logger1.fatal(&quot;fatal!!!&quot;);
    //在NT系统日志输出 
       Logger logger2 = Logger.getLogger(&quot;NTlog&quot;); 
       //NTEventLogAppender nla = new NTEventLogAppender(); 
       logger2.debug(&quot;debug!!!&quot;); 
       logger2.info(&quot;info!!!&quot;); 
       logger2.warn(&quot;warn!!!&quot;); 
       logger2.error(&quot;error!!!&quot;); 
       //只有这个错误才会写入2000日志 
       logger2.fatal(&quot;fatal!!!&quot;);
    //把日志发送到mail 
       Logger logger3 = Logger.getLogger(&quot;MailLog&quot;); 
       //SMTPAppender sa = new SMTPAppender(); 
       logger3.warn(&quot;warn!!!&quot;); 
       logger3.error(&quot;error!!!&quot;); 
       logger3.fatal(&quot;fatal!!!&quot;); 
      } 
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/ITEagle/archive/2010/04/23/1718365.html&quot;&gt;转自cnblogs&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 07 Feb 2017 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2017/02/07/log4j-configuration/</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2017/02/07/log4j-configuration/</guid>
        
        <category>java</category>
        
        <category>log4j</category>
        
        
      </item>
    
      <item>
        <title>配置Linux Service例子</title>
        <description>&lt;p&gt;##Linux Service配置
今天参照下面的脚本二写了一个脚本，作为Service运行。查找了网上的一些资料，Linux的service命令其实就是去执行&lt;code&gt;/etc/init.d/&lt;/code&gt;目录下的命令程序。网上有一些脚本设置提到过chkconfig命令，实测Debian8和Ubuntu14.04上并不需要使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service yourServiceName start/stop/restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将你的脚本移动到&lt;code&gt;/etc/init.d/yourServiceName.sh&lt;/code&gt;，即可通过上面方式把你的脚本程序运行起来。&lt;/p&gt;

&lt;p&gt;PS:写脚本的过程中遇到一个Bug，将PATH关键字作为了一个普通变量名使用，导致各种command not found。实在是太傻了。&lt;/p&gt;

&lt;p&gt;##下面是參考的网上关于Java后台脚本运行的例子：
脚本一：&lt;/p&gt;

&lt;p&gt;startTest.sh内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
java -jar Test.jar &amp;amp;     #注意：必须有&amp;amp;让其后台执行，否则没有pid生成
echo $! &amp;gt; /var/run/Test.pid   # 将jar包启动对应的pid写入文件中，为停止时提供pid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;stopTest.sh内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
PID=$(cat /var/run/Test.pid)
kill -9 $PID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;脚本二：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /bin/sh

#启动方法
start(){
       java -Xms128m -Xmx2048m -jar test1.jar 5 &amp;gt; log.log &amp;amp;
    	java -Xms128m -Xmx2048m -jar test2.jar 5 &amp;gt; log.log &amp;amp;
        tail -f result.log
}
#停止方法
stop(){
    	ps -ef|grep test|awk '{print $2}'|while read pid
        do
 	          kill -9 $pid
    	done
}

case &quot;$1&quot; in
start)
  start
  ;;
stop)
  stop
  ;;
restart)
  stop	
  start
  ;;
*)
  printf 'Usage: %s {start|stop|restart}\n' &quot;$prog&quot;
  exit 1
  ;;
esac
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 18 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2017/01/18/service-templet/</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2017/01/18/service-templet/</guid>
        
        <category>service</category>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>vim技巧,不定时更新</title>
        <description>&lt;h3 id=&quot;vim&quot;&gt;Vim多行缩进技巧&lt;/h3&gt;

&lt;p&gt;1.按v进入visual状态，选择多行，用&amp;gt;或&amp;lt;缩进或缩出&lt;/p&gt;

&lt;p&gt;2.通常根据语言特征使用自动缩进排版：在命令状态下对当前行用== （连按=两次）, 或对多行用n==（n是自然数）表示自动缩进从当前行起的下面n行。你可以试试把代码缩进任意打乱再用n==排版，相当于一般IDE里的code format。使用gg=G可对整篇代码进行排版。&lt;/p&gt;

&lt;p&gt;3.gg   shift+G 首尾&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2017/01/01/vim/</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2017/01/01/vim/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>定时触发工具</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;起由&lt;/h2&gt;
&lt;p&gt;前段时间，需要做一个功能和其他人的部分对接传递数据。由于存在版本不兼容问题，没有去合并项目。决定通过定时的方式访问数据库。获取一些更新的数据，进行处理。&lt;/p&gt;

&lt;h2 id=&quot;config&quot;&gt;Config&lt;/h2&gt;
&lt;p&gt;This is the big bit! Quartz is a very configurable application. The best way to configure Quartz is to edit a quartz.properties file, and place it in your application’s classpath (see Installation section above).&lt;/p&gt;

&lt;p&gt;There are several example properties files that ship within the Quartz distribution, particularly under the examples/ directory. I would suggest you create your own quartz.properties file, rather than making a copy of one of the examples and deleting the bits you don’t need. It’s neater that way, and you’ll explore more of what Quartz has to offer.&lt;/p&gt;

&lt;p&gt;Full documentation of available properties is available in the Quartz Configuration Reference.&lt;/p&gt;

&lt;p&gt;To get up and running quickly, a basic quartz.properties looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;org.quartz.scheduler.instanceName = MyScheduler
org.quartz.threadPool.threadCount = 3
org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The scheduler created by this configuration has the following characteristics:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;org.quartz.scheduler.instanceName - This scheduler’s name will be “MyScheduler”.&lt;/li&gt;
  &lt;li&gt;org.quartz.threadPool.threadCount - There are 3 threads in the thread pool, which means that a maximum of 3 jobs can be run simultaneously.&lt;/li&gt;
  &lt;li&gt;org.quartz.jobStore.class - All of Quartz’s data, such as details of jobs and triggers, is held in memory (rather than in a database). Even if you have a database and want to use it with Quartz, I suggest you get Quartz working with the RamJobStore before you open up a whole new dimension by working with a database.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;quartz&quot;&gt;Quartz&lt;/h2&gt;
&lt;p&gt;Now you’ve downloaded and installed Quartz, it’s time to get a sample application up and running. The following code obtains an instance of the scheduler, starts it, then shuts it down:
Quartz.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.impl.StdSchedulerFactory;
import static org.quartz.JobBuilder.*;
import static org.quartz.TriggerBuilder.*;
import static org.quartz.SimpleScheduleBuilder.*;

public class QuartzTest {
	public static void main(String[] args) {
		try {
			// Grab the Scheduler instance from the Factory
			Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();

			// and start it off
			scheduler.start();

			scheduler.shutdown();

			} catch (SchedulerException se) {
				se.printStackTrace();
			}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 01 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2016/12/01/job-schdule-quartz/</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2016/12/01/job-schdule-quartz/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>Android开发及使用技巧</title>
        <description>&lt;h3 id=&quot;wifi&quot;&gt;1. 查看wifi密码&lt;/h3&gt;

&lt;p&gt;查询连接的wifi密码，没问题，前提是手机已经root了，可以查看系统文件，android的wifi密码明文保存在一下文件中，使用root explorer查看即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/data/misc/wifi/wpa_supplicant.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;activity&quot;&gt;2. 查看activity堆栈情况&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;adb shell dumpsys activity ---------------查看ActvityManagerService 所有信息
adb shell dumpsys activity activities ----------查看Activity组件信息
adb shell dumpsys activity services -----------查看Service组件信息
adb shell dumpsys activity providers ----------产看ContentProvider组件信息
adb shell dumpsys activity broadcasts --------查看BraodcastReceiver信息
adb shell dumpsys activity intents --------------查看Intent信息
adb shell dumpsys activity processes ---------查看进程信息
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;apkandroidmanifestxml&quot;&gt;3. 查看apk中的AndroidManifest.xml文件&lt;/h3&gt;

&lt;p&gt;可以使用apktool对apk进行反编译，不过现在很多的apk都进行了加固，可以防止apktool进行反编译，我们可以使用google提供的aapt(Android Asset Packaging Tool)进行查看:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aapt dump xmltree target.apk AndroidManifest.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;其中target.apk为需要查看AndroidManifest.xml的apk包。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;androidlog&quot;&gt;4. 查看android的log&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;adb logcat

&quot;-s&quot;选项 : 设置输出日志的标签, 只显示该标签的日志;

&quot;-f&quot;选项 : 将日志输出到文件, 默认输出到标准输出流中, -f 参数执行不成功;

&quot;-r&quot;选项 : 按照每千字节输出日志, 需要 -f 参数, 不过这个命令没有执行成功;

&quot;-n&quot;选项 : 设置日志输出的最大数目, 需要 -r 参数, 这个执行 感觉 跟 adb logcat 效果一样;

&quot;-v&quot;选项 : 设置日志的输出格式, 注意只能设置一项;

&quot;-c&quot;选项 : 清空所有的日志缓存信息;

&quot;-d&quot;选项 : 将缓存的日志输出到屏幕上, 并且不会阻塞;

&quot;-t&quot;选项 : 输出最近的几行日志, 输出完退出, 不阻塞;

&quot;-g&quot;选项 : 查看日志缓冲区信息;

&quot;-b&quot;选项 : 加载一个日志缓冲区, 默认是 main, 下面详解;

&quot;-B&quot;选项 : 以二进制形式输出日志;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;持续更新…&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 28 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2015/07/28/android-trick/</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2015/07/28/android-trick/</guid>
        
        <category>android</category>
        
        
      </item>
    
      <item>
        <title>获取所有分组中某列最大的行</title>
        <description>&lt;p&gt;&lt;strong&gt;怎么获取所有分组中某列最大的行？&lt;/strong&gt;下面用一个例子来说明下：&lt;/p&gt;

&lt;p&gt;一共公司有若干员工，每个员工有各自的id, group_id(部门), salary(工资).现在的问题转变为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;求公司各部门最高工资的员工
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先明确一个问题，一个部门的若干个员工可能同时拥有最高的工资，需要都列举出来。&lt;/p&gt;

&lt;p&gt;看一下员工的数据库表结构(只包含有用的列):&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Field&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
      &lt;th&gt;Null&lt;/th&gt;
      &lt;th&gt;Key&lt;/th&gt;
      &lt;th&gt;Default&lt;/th&gt;
      &lt;th&gt;Extra&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;id&lt;/td&gt;
      &lt;td&gt;int(11)&lt;/td&gt;
      &lt;td&gt;NO&lt;/td&gt;
      &lt;td&gt;PRI&lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;group_id&lt;/td&gt;
      &lt;td&gt;int(11)&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;salary&lt;/td&gt;
      &lt;td&gt;int(11)&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;添加的测试数据如下:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;group_id&lt;/th&gt;
      &lt;th&gt;salary&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;300&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们需要做的步骤如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;获取各个部门最高的工资&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;查找各个部门工资等于最高工资的员工&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;获取各个部门最高的工资&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;select group_id, max(salary) as max_salary from employee group by group_id ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后的结果:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;group_id&lt;/th&gt;
      &lt;th&gt;max_salary&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;300&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;section-1&quot;&gt;查找各个部门工资等于最高工资的员工&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;select a.id, a.group_id, a.salary from employee as a, b where a.group_id=b.group_id and a.salary=b.max_salary ;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;假设第一执行后的数据存在表b中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样就得到了最终的结果:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;group_id&lt;/th&gt;
      &lt;th&gt;salary&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;300&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们可以简单的将&lt;strong&gt;获取各个部门最高的工资&lt;/strong&gt;的代码替换b即可，组合后的语句如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select a.id, a.group_id, a.salary from employee as a, (select group_id, max(salary) as max_salary from employee group by group_id) as b where a.group_id=b.group_id and a.salary=b.max_salary ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后的结果相同。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;总结&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;我们首先按照部门进行分组，获取每组最大的工资(表b); 之后将表a(原表)与表b做一下笛卡尔积，筛选出我们需要的数据即可。
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 20 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2015/07/20/get-max-from-every-group/</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2015/07/20/get-max-from-every-group/</guid>
        
        <category>database</category>
        
        
      </item>
    
      <item>
        <title>Android WebView页面加载优化</title>
        <description>&lt;p&gt;目前webapp越来越多，体验也越来越好，为了能够更好的使用WebView展示出流畅的的页面，可以从以下几点做优化：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;WebView缓存&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;资源文件本地存储&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;减少耗时操作&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;客户端UI优化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可能有人会说了，为什么不做成native的呢，这样就不用那么的麻烦了。如果我需要加载的内容都是静态的，当然做成native的是最好的，为什么我们要使用WebView呢，因为它可以加载一些容易改变的内容，同时也方便制作多平台应用。&lt;/p&gt;

&lt;p&gt;WebView可以优化的哪些地方呢?&lt;/p&gt;

&lt;h3 id=&quot;webview&quot;&gt;WebView缓存&lt;/h3&gt;

&lt;p&gt;开启WebView的缓存功能可以减少对服务器资源的请求，一般使用默认缓存策略就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//设置 缓存模式 
webView.getSettings().setCacheMode(WebSettings.LOAD_DEFAULT);  
// 开启 DOM storage API 功能 
webView.getSettings().setDomStorageEnabled(true); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;资源文件本地存储&lt;/h3&gt;

&lt;p&gt;资源等文件(不需要更新)本地存储，在需要的时候直接从本地获取。哪些资源需要我们去存储在本地呢，当然是一些不会被更新的资源，例如图片文件，js文件，css文件，替换的方法也很简单，重写WebView的方法即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
      try {
	      if (url.endsWith(&quot;icon.png&quot;)) {
	          InputStream is = appRm.getInputStream(R.drawable.icon);
	          WebResourceResponse response = new WebResourceResponse(&quot;image/png&quot;,
	            &quot;utf-8&quot;, is);
	          return response;
	      } else if (url.endsWith(&quot;jquery.min.js&quot;)) {
	          InputStream is = appRm.getInputStream(R.raw.jquery_min_js);
	          WebResourceResponse response = new WebResourceResponse(&quot;text/javascript&quot;,
	            &quot;utf-8&quot;, is);
	          return response;
	      }
	      } catch (IOException e) {
	     		 e.printStackTrace();
	      }
	      return super.shouldInterceptRequest(view, url);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;appRm为app资源管理器，读取drawable，assets，raw下的资源，都是android系统的一些很简单的函数调用。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;getInputStream的参数代表资源具体位置&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;WebResourceResponse后的资源类型需要写正确&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;有些时候我们会为我们的网站加入一些统计代码，这些也可以精简掉(自己使用的CNZZ的大概占的有10k左右)，可以使用Charles对客户端进行抓包查看。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;减少耗时操作&lt;/h3&gt;

&lt;p&gt;准确的说，是减少同步操作的操作时间，尽量使用异步操作替代同步操作。如果服务端存在读取数据库和计算耗时的操作，尽量使用异步(ajax)进行操作，把原本的时间花在异步操作上。&lt;/p&gt;

&lt;p&gt;举个例子，A页面到B页面，A页面实现登录功能，B页面展示主功能页面，如果让B页面去进行用户登录信息验证的话，B页面加载时间会加长(数据库查询等操作)，同时客户端可能需要提供一个等待框(或进度条等)给用户，那看看在A页面使用异步操作的优势吧：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以提供统一的js等待框，多平台保持一致性，减少客户端代码工作量。&lt;/li&gt;
  &lt;li&gt;加载页面的时间变短。B页面由于减少了耗时的操作，加载时间变短，用户等待时间也变短。&lt;/li&gt;
  &lt;li&gt;可以方便加入一些验证后的控制逻辑，不需要进行页面跳转。A页面可以根据异步操作进行结果判断，做出相应的处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ui&quot;&gt;客户端UI优化&lt;/h3&gt;

&lt;p&gt;怎么让用户看不到WebView加载前的白色页面呢？首次加载后页面的跳转可以用上面的步骤进行优化，可以提供给用户一个很好的体验，那加载的第一页呢？我们需要WebView预加载页面，这个该怎么做到的呢？下面提供两种方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ViewPager，将欢迎页面与WebView页面一起放进ViewPager中，设置预加载页面个数，使WebView所在页面可以预加载，在加载完毕的时候切换到WebView所在页面。&lt;/li&gt;
  &lt;li&gt;FrameLayout，将欢迎页面与WebView页面的布局合在一起，显示在一个页面内，起始隐藏WebView布局，待WebView加载完毕，隐藏欢迎布局，显示WebView布局。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用FrameLayout简单一些，两种方法都是需要对WebChromeClient的onProgressChanged进行监听，加载完毕进行页面切换，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  webView.setWebChromeClient(new WebChromeClient() {
        @Override
        public void onProgressChanged(WebView view, int newProgress) {
            super.onProgressChanged(view, newProgress);
            if (newProgress &amp;gt;= 100) {
                // 切换页面
            }
        }
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过以上几步的优化，一个流畅的webapp生成了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 17 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2015/07/17/android-webview-optimize/</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2015/07/17/android-webview-optimize/</guid>
        
        <category>android</category>
        
        <category>network</category>
        
        
      </item>
    
      <item>
        <title>给jekyll添加炫酷简洁的搜索</title>
        <description>&lt;p&gt;试试&lt;strong&gt;双击Ctrl键&lt;/strong&gt;看看，或者点击&lt;strong&gt;右下角搜索图标&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;博客从wordpress的jekyll，jekyll的核心思想:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;将纯文本转化为静态网站和博客
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。&lt;/p&gt;

&lt;p&gt;jekyll没有数据库支持，默认没有搜索功能，那么怎么添加炫酷简洁的搜索的功能呢？google一下，大部分都是使用插件之类的，起始我们可以直接在服务端产生索引，之后利用索引进行搜索。&lt;/p&gt;

&lt;p&gt;受到spotlight的简洁启发，在目前小胖轩导航栏上已经没有空间了，于是打算做出一个类似于spotlight的搜索。下面先看一下操作步骤：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;① 服务端生成文章索引
② 浏览器获取文章索引
③ 页面交互以及按键控制
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;服务器生成文章索引&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;---
layout: null
---
{
	&quot;code&quot; : 0 ,
	&quot;data&quot; : [
	 {\% for post in site.posts \%}
	{
		&quot;title&quot; : &quot; - {\% for tag in post.tags \%}{\% if forloop.rindex != 1 \%}_{\% else \%}{\% endif \%}{\% endfor \%}&quot;,
		&quot;url&quot; : &quot;&quot;
	}
	{\% if forloop.rindex != 1  \%}
	,
	{\% endif \%}
    {\% endfor \%}
	]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;由于文章中的动态代码会被解析，所以做了替换，代码中%被替换成\%,使用中请去除%前面的转义符&lt;/li&gt;
    &lt;li&gt;liquid语言对行敏感，如果需要把2个字符串拼接一起，那么字符串必须在同一行，否则字符串间将加入回车符&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;这段代码是一个双层循环，将文章的标题与标签组合，同时和url一起组合为json字符串，方便后续ajax调用。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;浏览器获取文章索引&lt;/h3&gt;

&lt;p&gt;此处也即一个ajax调用，使用$.ajax或者$.getJson都可以，此处可以参考一下ajax的异步请求。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;页面交互以及按键控制&lt;/h3&gt;

&lt;p&gt;为了能够有一个更好的交互，对搜索进行了很多的按键的操作:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PC下双击Ctrl键打开或者关闭搜索框&lt;/li&gt;
  &lt;li&gt;搜索框展示时按下Esc键关闭搜索框&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按键的检测在js中也是很容易进行，此处也不在列代码了。&lt;/p&gt;

&lt;p&gt;为了移动端也可以很好的搜索，在页面的右下角加入搜索悬浮按钮，点击后打开搜索页面，而在搜索页面，右上角提供关闭按钮，这样整体下来就完美的实现了搜索。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 11 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2015/07/11/jekyll-search/</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2015/07/11/jekyll-search/</guid>
        
        <category>web</category>
        
        
      </item>
    
      <item>
        <title>a+=b 等价于 a=a+b ?</title>
        <description>&lt;p&gt;&lt;strong&gt;a += b&lt;/strong&gt;和&lt;strong&gt;a = a + b&lt;/strong&gt;完全等价么(java)？可能很多人以为是一样的，其实并非等价的，下面看一下证据吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Test {
    public static void main(String[] args) {
        int a = 0;
        float c = 2.0f;
        a += c;
        a = a +  c;  //①
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码有问题么？ 能够通过编译么？ 答案是&lt;strong&gt;否定的&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ javac Test.java
Test.java:6: error: possible loss of precision
         a = a +  c;
               ^
  required: int
  found:    float
1 error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出现的问题是编译错误， 但是&lt;strong&gt;a += c&lt;/strong&gt;却不会出现编译错误，能够正常通过编译。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么为这样呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们将&lt;strong&gt;①&lt;/strong&gt;处代码去除后，顺利编译，可以使用jd-gui等工具看一下&lt;strong&gt;a += c&lt;/strong&gt;的反编译后的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Test
{
  public static void main(String[] paramArrayOfString)
  {
    int i = 0;
    float f = 2.0F;
    i = (int)(i + f);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看一下以下这句:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; i = (int)(i + f);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出&lt;strong&gt;a += c&lt;/strong&gt;在编译的时候做了强制类型转换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;结论: 
对于 a += c
如果a的类型可以兼容b，则 (a += c) 等价于 (a = a + c) 
否则，则会在a与c做完加法后进行强制转换。
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 10 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2015/07/10/java-operate/</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2015/07/10/java-operate/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>图片灰度化</title>
        <description>&lt;p&gt;怎么将图片灰度化，看到一个黑白滤镜的实现，黑白滤镜原理十分简单,是根据各种颜色在人眼中的亮度响应将rgb三通道的像素转换成单通道的灰度像素.而对于彩色转灰度,有一个很著名的心理学公式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Gray = R*0.299 + G*0.587 + B*0.114 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面看一下具体怎么使用，怎么讲一张彩色照片转变为黑白照片。看一段java代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package me.codeboy.lyd.image;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

/**
 * Created by yuedong on 7/2/15.
 */
public class GrayImage {
    public static void main(String[] args) throws IOException {
        File file = new File(&quot;src.png&quot;);
        File out = new File(&quot;out.png&quot;);
        BufferedImage image = ImageIO.read(file);
        int width = image.getWidth();
        int height = image.getHeight();
        for (int i = 0; i &amp;lt; width; i++) {
            for (int j = 0; j &amp;lt; height; j++) {
                int rgb = image.getRGB(i, j);
                int r = rgb &amp;amp; 0x00ff0000 &amp;gt;&amp;gt; 16;
                int g = rgb &amp;amp; 0x0000ff00 &amp;gt;&amp;gt; 8;
                int b = rgb &amp;amp; 0x000000ff;

        //根据公式计算
        int color = (int) (r * 0.299 + g * 0.587 + b * 0.114);
        image.setRGB(i, j, new Color(color, color, color).getRGB());
        }
    }
    ImageIO.write(image, &quot;PNG&quot;, out);

    //rgb相同下产生的图片
    BufferedImage colorImage = new BufferedImage(256, 256 * 3, BufferedImage.TYPE_3BYTE_BGR);
    for (int i = 0; i &amp;lt; 256; i++) {
        for (int j = 0; j &amp;lt; 256 * 3; j++) {
            int k = j/3;
            colorImage.setRGB(i,j,new Color(k,k,k).getRGB());
        }
    }

    File colorFile = new File(&quot;color.png&quot;);
    ImageIO.write(colorImage, &quot;PNG&quot;, colorFile);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码进行了2个操作，一个讲图片进行灰度化，怎么进行灰度化呢，可以看出，仅仅是获取每一个点的rgb值，按照公式计算出灰度值，然后设置新的rgb值，每一个r,g,b的值都是这个灰度值。处理前后的照片如下:
&lt;img src=&quot;/img/image-src.png&quot; alt=&quot;img&quot; /&gt;
&lt;img src=&quot;/img/image-gray.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么呢？因为r=g=b时，获取的颜色的区间就是由黑到白，紧接着的代码就是将r=g=b的颜色绘制出来，图片如下(最上面的是r=g=b=0,最下面的是r=g=b=255):
&lt;img src=&quot;/img/image-rgb.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 02 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2015/07/02/image-gray/</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2015/07/02/image-gray/</guid>
        
        <category>java</category>
        
        <category>discover</category>
        
        
      </item>
    
  </channel>
</rss>
